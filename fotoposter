import os
import time
from datetime import datetime, timedelta, timezone
from atproto import Client

# === CONFIG ===
MAX_POSTS_PER_RUN = 30          # maximaal aantal reposts per run
MAX_POSTS_PER_USER = 2          # maximaal aantal reposts per gebruiker
DELAY_BETWEEN_POSTS = 2         # seconden wachttijd tussen reposts
LOOKBACK_HOURS = 2              # kijkt 2 uur terug in de feed

# Feed komt uit GitHub Secret (veilig)
FEED_URI = os.getenv("BSKY_FEED_URI")

def log(msg: str):
    """Interne logfunctie zonder gevoelige data"""
    now = datetime.now().strftime("%H:%M:%S")
    print(f"[{now}] {msg}")

def login(username: str, password: str) -> Client:
    client = Client()
    client.login(username, password)
    return client

def get_recent_feed_posts(client: Client, feed_uri: str):
    """Haalt alleen posts van de laatste LOOKBACK_HOURS uren op"""
    feed = client.app.bsky.feed.get_feed({"feed": feed_uri, "limit": 100}).feed
    cutoff = datetime.now(timezone.utc) - timedelta(hours=LOOKBACK_HOURS)
    recent_posts = []

    for item in reversed(feed):  # oudste eerst
        post = item.post
        created_at = getattr(post.record, "createdAt", None)
        if not created_at:
            continue
        try:
            post_time = datetime.fromisoformat(created_at.replace("Z", "+00:00"))
        except Exception:
            continue

        if post_time >= cutoff:
            recent_posts.append({
                "uri": post.uri,
                "cid": post.cid,
                "author": post.author.did
            })

    return recent_posts

def repost_and_like_feed(client: Client, feed_uri: str):
    """Repost en like recente posts binnen limieten"""
    if not feed_uri:
        log("❌ Geen feed ingesteld (BSKY_FEED_URI ontbreekt).")
        return

    log("📡 Ophalen recente posts...")
    posts = get_recent_feed_posts(client, feed_uri)
    log(f"Gevonden {len(posts)} recente posts binnen {LOOKBACK_HOURS} uur.")

    seen_uris = set()
    per_user = {}
    reposted_count = 0

    for post in posts:
        if reposted_count >= MAX_POSTS_PER_RUN:
            break

        user_count = per_user.get(post["author"], 0)
        if user_count >= MAX_POSTS_PER_USER:
            continue
        if post["uri"] in seen_uris:
            continue

        try:
            # === Repost ===
            client.app.bsky.feed.repost.create(
                repo=client.me.did,
                record={
                    "subject": {"uri": post["uri"], "cid": post["cid"]},
                    "createdAt": client.get_current_time_iso(),
                    "$type": "app.bsky.feed.repost",
                },
            )

            # === Like ===
            client.app.bsky.feed.like.create(
                repo=client.me.did,
                record={
                    "subject": {"uri": post["uri"], "cid": post["cid"]},
                    "createdAt": client.get_current_time_iso(),
                    "$type": "app.bsky.feed.like",
                },
            )

            reposted_count += 1
            per_user[post["author"]] = user_count + 1
            seen_uris.add(post["uri"])

            log(f"✅ Repost + like uitgevoerd ({reposted_count}/{MAX_POSTS_PER_RUN})")

            if reposted_count < MAX_POSTS_PER_RUN:
                log(f"⏱ Wachten {DELAY_BETWEEN_POSTS}s...")
                time.sleep(DELAY_BETWEEN_POSTS)

        except Exception as e:
            log(f"⚠️ Fout bij een actie: {e}")
            continue

    log(f"🎯 Klaar: {reposted_count} posts gerepost + geliked.")

def main():
    username = os.getenv("BSKY_USERNAME")
    password = os.getenv("BSKY_PASSWORD")

    if not username or not password:
        log("❌ Geen inloggegevens gevonden (BSKY_USERNAME/BSKY_PASSWORD).")
        return

    client = login(username, password)
    repost_and_like_feed(client, FEED_URI)

if __name__ == "__main__":
    main()